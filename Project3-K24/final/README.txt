Ευστάθιος Χατζηλοΐζος - sdi1800212
Project3 - K24 Unix System Programming
--------------------------------------


travelMonitorClient + monitorServer
-----------------------------------
Compilation: make
Παράδειγμα: ./travelMonitorClient -m 6 -b 100 -c 10 -s 10000 -i inputDir -t 10

Το πρόγραμμα χρησιμοποιεί sockets για την επικοινωνία μεταξύ των διεργασιών. Συγκεκριμένα,
το travelMonitorClient και το κάθε ένα απο τα monitorServer επικοινωνούν μέσω του δικου τους socket.
Η υλοποίηση ακολουθεί το πρότυπο που ειπώθηκε στο piazza, δηλαδή το travelMonitorClient δημιουργεί
τα sockets και περιμένει τα monitorServers να συνδεθούν σε αυτό. Δηλαδή, το travelMonitorClient
λειτουργεί ως server και τα monitorServers ως clients που συνδέονται στο server. Η επικοινωνία του
κάθε monitorServer με τον travelMonitorClient γίνεται μέσω μοναδικού socket και όχι μέσω δύο,
διαφορετικά δηλαδή απο το Project2. Κρατούνται μόνο οι απαραίτητες δομές, αρκετές από το Project1,
που στοχεύουν στην όσο το δυνατό καλύτερη ταχύτητα αναζήτησης σε συνδυασμό με την οικονομία μνήμης.
Αρχικά, ο travelMonitorClient κάνει fork-exec με τα σωστά arguments τα monitorServers που ορίζει
ο χρήστης. O τρόπος γεμίσματος των δομών του κάθε monitorServer είναι αρκετά διαφορετικός
απο αυτόν του Project2. Δημιουργούνται τα threads που ορίζει ο user και τραβάνε αρχεία από
το buffer εως ότου να αδειάσει το buffer που τα διατηρεί. Εφόσον αδειάσει, τα threads μπλοκάρονται
μέχρι να υπάρξει κάποιο άλλο αρχείο στο buffer για να διαβάσουν. Αν έχουν διαβαστεί ολα τα
αρχεία	που καλείται να διαβάσει το συγκεκριμένο monitorServer, τότε τα threads κανουν exit.
Αν δωθούν παραπάνω threads απο ότι αρχεία καλούνται να διαβαστούν, το monitorServer φτιάχνει
μόνο τόσα όσα χρειάζονται. Μόλις οι δομές είναι πλήρεις, οι monitorServers στέλνουν τα bloom filters
και περιμένουν τις εντολές του travelMonitorClient. Όλες εντολές οι εντολές, πλην της
addVaccinationRecords που δεν έχει υλοποιηθέι εκτελούνται όπως ακριβώς ορίζει η εκφώνηση και έχουν
γίνει οι απαραίτητες μετατροπές αυτών απο το Project2. Με exit το προγραμμα ολοκληρώνει φτιάχνοντας
τα log_files, ελευθερώνεται η μνήμη, οι δομές, τα sockets τα mutexes και το condition variable.

Για να αποφευχθούν race conditions και λοιπά προβλήματα εχουν προστεθεί mutexes και condition
variable, τοσα ώστε να επηρεάζεται οσο το δυνατόν λιγότερο το concept του παραλληλισμού του Project.

Το πρόγραμμα ανταποκρίνεται στην εκφώνηση εκτος απο μερικα σημεία:
- το cyclic buffer έχει αντικαταστηθεί απο ενα buffer που κρατάει όλα τα αρχεία
- Δεν έχει υλοποιηθεί η addVaccinationRecords

Τα bloom filters στέλνονται λαμβάνωντας υπ' οψην το buffer_size και έχουν ελεγθεί εως και
για buffer_size 2 bytes. Όπως έχει ειπωθεί και απαντηθεί απο τους καθηγητές στο piazza,
υποθέτω οτι το buffer_size δεν θα ξεπερνάει τα 512 bytes. Για την ακρίβεια, εκτός του bloom
filter οι διεργασίες μου για τις λοιπές τους επικοινωνίες δεν ξεπερνόυν τα 30 bytes ανα μηνυμα.

Το κάθε monitorServer κρατάει με ακρίβεια τα στατιστικά accepted/rejected/total μιας και μετα απο
καθε travelRequest το monitorServer που διαχειρίζεται το countryTo ενημερώνεται για το αποτέλεσμα
του request και για το αν τελικά θα δεχτεί ή όχι τον πολίτη με citizen_id.

Εκτενή σχόλια εξηγούν λεπτομερώς κάθε κομμάτι της υλοποίησής.
